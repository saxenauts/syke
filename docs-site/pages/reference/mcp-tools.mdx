import { Callout, Tabs } from 'nextra/components'

# MCP Tools Reference

Syke's MCP server exposes 3 tools — a minimal, intentional interface.

<Callout type="info">
**Pattern**: `get_live_context` first → `ask` if needed → `record` when something happens.

`get_live_context` and `record` work without any API key. `ask` requires `ANTHROPIC_API_KEY` or `claude login` (Claude Code Max/Team/Enterprise).
</Callout>

## get_live_context

**Start here.** Returns the memex — the synthesized map of who this person is. Instant, zero-cost.

Not a database lookup — it's a living model synthesized from cross-platform signals (code, conversations, commits, emails). Updated every sync cycle.

**Parameters:**
- `format` (string, optional): `json` | `markdown` | `claude-md` | `user-md`. Default: `json`

**Returns:** The user's memex — current projects, communication style, recent context, cross-platform threads, technical skills, world state.

**When to use:**
```
"What is the user working on?"           → get_live_context (it's right there)
"How do they prefer error messages?"     → get_live_context (communication style)
"What did they think about X 3 weeks ago?" → ask (needs timeline exploration)
```

**Example request:**
```json
{"name": "get_live_context", "arguments": {"format": "markdown"}}
```

---

## ask

Ask any question about the user in natural language. Syke's internal agent reads the memex, then explores the memory layer and raw timeline to find the answer.

More thorough than direct queries, but takes 5–25 seconds and costs ~$0.10–0.20 per call.

**Parameters:**
- `question` (string, required): Natural language question about the user.

**Returns:** A synthesized answer based on the user's full digital footprint.

**Requires:** `ANTHROPIC_API_KEY` or `claude login` (Claude Code Max/Team/Enterprise).

**Examples:**
```json
{"name": "ask", "arguments": {"question": "What did they work on last week?"}}
{"name": "ask", "arguments": {"question": "What do they think about RAG architectures?"}}
{"name": "ask", "arguments": {"question": "Find the decision about JWT vs session tokens"}}
```

Use `ask` for anything `get_live_context` doesn't answer. The agent has 9 read tools internally — it searches memories, follows links, cross-references platforms, and browses the timeline.

---

## record

Push a meaningful observation back into the user's timeline. Natural language, no structure needed.

The daemon already captures sessions, commits, and conversations automatically. Use `record` for signals the daemon can't see: decisions made in conversation, preferences expressed, frustrations, insights.

**Parameters:**
- `observation` (string, required): What you observed, in natural language.

**Returns:** `{"status": "recorded"}` or `{"status": "already_known"}` (dedup by content hash).

**Examples:**
```json
{"name": "record", "arguments": {"observation": "User decided to use PostgreSQL over MongoDB"}}
{"name": "record", "arguments": {"observation": "Finished the auth refactor and merged PR #42"}}
{"name": "record", "arguments": {"observation": "Prefers dark mode, mentioned it twice today"}}
```

**When to call:** Decisions, task completions, strong preferences, new collaborations, project shifts.
**When NOT to call:** Every message (too noisy), trivial observations, info already in the live context.
